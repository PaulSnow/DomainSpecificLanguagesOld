package com.dtrules.compiler.tiers_compiler.cup.parser;
import java_cup.runtime.*;

/************************************************************************************************
* Language specifications for Rules Engine syntax. We follow BNF standards for defining rules.
* @author Simran Kamboj
*************************************************************************************************/

action code {:

    private String firstexp;		
    
    public String checkRList(String rList){
       return rList;       
    }
    
    public String checkEntity(String entity)
      throws Error
    {
       return entity;
    }
    
    public String checkReadOnly(String attribute)
      throws Error
    {
       return attribute;
    }    
:}

parser code {:    
        
            
    public void report_error(String message, Object info) 
    			throws Error
    {
        StringBuffer m = new StringBuffer("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {      
                m.append(" in line "+(s.left+1));   
                if (s.right >= 0)   
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.out.println(m);
	    // this.done_parsing();
	    // throw new Error(m.toString());
    }
   
    public void report_fatal_error(String message, Object info) 
    		throws Error
    {
        report_error(message, info);    
    }

:};
   
/* ------------Declaration of Terminals and Non Terminals Section----------- */

terminal String EOP, PLUS, MINUS, TIMES, DIVIDE, LPAREN, RPAREN, LESSTHAN, GREATERTHAN, OR, PLUSSTR,
	          EQUALS, NOTEQUALS, GREATERTHANEQUALS, LESSTHANEQUALS, AND, NOT, COMMA, 
		    DUMMY, GREATEROF, LESSEROF, ROUNDED, ORMORE, SCALED, DECPLACES, UNIMINUS,
		    LOOKUP, CODE, USINGCOLUMN, FROMTABLE, FORDATE, THEREISNO, WITHIN, 
                END, OF, START, ON, RETURNING,BETWEEN;

terminal String TABLENAME, APOSTFIX, CPOSTFIX, USROPER, TRUEIF, FALSEIF;

terminal String SUBSTRINGOF, FINDAPERSON, FINDINDIVIDUAL, ANDFINDINDIVIDUAL, 
                FINDALLPERSONS,FINDAENTITY, FINDAELEMENT, ANDFINDREFERNCEDINDIVIDUAL,
                SORT, ASCENDING, DESCENDING, BY,
                FINDALLEDGINDIVIDUAL, IF, THEN, ANDSET, SIZEOF,
                COPY, FORMAGROUP, CALLED, ADDALL, ADDALL_EDG_INDV, ADD, TO, ANDFOREACH, TOAPERSON,
                SKIP, USING, LISTEQUALS,
                ISA, HASA, HAS, HASAPERSON, WHOHASA, WHERE, IN, ANDTHEIR, ELEMENT,
                ISTHERE, EDGINDIVHAS,SUMOFEACH,
                FORALL, FOREACH,IS, ARROW,
                CONDITION, ACTION, EXIT, THROWRULESEXCEPTION,
                DOES, EVERY, FOREVERY, OFINDIVIDUALHAVE,
                ACOPYOFALLMEMBERSIN, 
                EACH, REMOVE, FROM, ISAMEMBEROF, INCLUDESMEMBER,
                TOTHECONTEXT,FINDTHEFIRST,ANDADDIT, FORANYOFTHE, FORALLOFTHE ; 

terminal String INTEGER, FLOAT, BIGDECIMAL,
                BOOL_ID, ID, ENTITY, RLIST, 
                STR, SET, BOOL, DATEMODIFIER, POSSESSION, TIMEPERIOD,ABSOLUTETIME,NUMBEROFTIMEPERIOD, COMMALIST;

non terminal String    goal;

non terminal String    statementList,
                       actionStatementList,    
                       actionStatement, 
                       conditionStatementList, 
                       conditionStatement;
                        
non terminal String    setStatement, 
                       performStatement, 
                       ifStatement,
                       sortStatement,
                       wherehasStatement,
                       forallStatement,
                       someofeachStatement, 
                       isaStatement, 
                       hasaStatement,
                       hasapersonStatement, 
                       whohasaStatement,
                       isthereStatement,
                       orSubstring,
                       isSubstring,
                       thereisnoStatement,
                       edgindivStatement,
                       findStatement, 
                       exitStatement,
                       doesStatement,
                       formGroupStatement,
                       copyStatement,
                       forAllEdgIndv,
                       isforeverytest,
                       removefromlist,
                       addtocontextStatement,
                       foranyalloftheStmnt,
                       foranyallwhereStmnt,
                       throwRulesException,
 			     lookupExpression,
                       deepcopyLists  ;

non terminal String    setPhrase, setPhrase2, whohasaTest, commaPhrase, commaListExpr;

non terminal String    commentblock;

non terminal String    term;

non terminal String    id, mid, number, boolexpr, expr, commaexpr, bexpression;


/* *>*>*>   P R E C E D E N C E   *<*<*<* */
/*========================================*/
   
precedence right        FORALL, ENTITY, RLIST, ID, ADDALL, FOREACH, USING, DOES, FORDATE;
precedence right        WHERE, LOOKUP, CODE, LPAREN;
precedence left         OR; 
precedence left         AND;
precedence left 	    POSSESSION, LESSTHAN, GREATERTHAN, EQUALS, NOTEQUALS;
precedence left         GREATERTHANEQUALS, LESSTHANEQUALS;
precedence right        ROUNDED, SCALED;
precedence left 	    PLUS, MINUS; 
precedence left 	    TIMES, DIVIDE, PLUSSTR;
precedence left         ARROW, SUMOFEACH,NOT, UNIMINUS, END, TIMEPERIOD, START;
precedence left         APOSTFIX, CPOSTFIX, EOP; 




/* ----------------------------Grammar Section-------------------- */ 
  start with goal;

  goal                    ::=  statementList:list EOP
                               {: RESULT = list; parser.done_parsing();
                               :}
                               ;

  statementList           ::=  statementList:list CONDITION conditionStatementList:list2
                               {: RESULT = list+"\n" + list2+"\n"; :}
                               |
                               statementList:list ACTION    actionStatementList:list2
                               {: RESULT = list+ "\n" + list2+"\n"; :}
                               |
                               CONDITION conditionStatementList:list 
                               {: RESULT =  list+"\n"; :}
                               |
                               ACTION    actionStatementList:list 
                               {: RESULT =  list +"\n"; :}
                               |
			                   statementList:list commentblock
                               {: RESULT = list; :}	
                               ;

  commentblock            ::=  SKIP ;                               
                                
  conditionStatementList  ::=  actionStatementList:list conditionStatement:stmt EOP  
                               {: RESULT = list + " " + stmt; :}
                               | 
                               conditionStatement:stmt EOP
                               {: RESULT = stmt; :}                                   
                               ;              

  actionStatementList     ::=  actionStatementList:list actionStatement:stmt EOP 
                               {: RESULT = list + " " + stmt; :}
                               | 
                               actionStatement:stmt EOP
                               {: RESULT = stmt; :}
                               ; 

  actionStatement         ::=  performStatement:stmt 
                               {: RESULT = stmt; :}
                               | 
                               exitStatement:stmt 
                               {: RESULT = stmt; :}
                               | 
                               setStatement:stmt 
                               {: RESULT = stmt; :}
                               | 
                               wherehasStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               forallStatement:stmt
                               {: RESULT = stmt; :}
                               | 
                               someofeachStatement:stmt
                               {: RESULT = stmt; :}
                               | 
                               findStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               formGroupStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               copyStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               ifStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               sortStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               addtocontextStatement:stmt
                               {: RESULT = stmt; :}
                               |
                               DUMMY:stmt
                               {: RESULT = " "; :}
                               |
                               APOSTFIX:stmt
                               {: RESULT = stmt; :}
                               |
                               USING id:id
                               {: RESULT = id + " entitypush "; :}
                               actionStatement:stmt
                               {: RESULT +=  stmt + " entitypop "; :}
                               |
                               forAllEdgIndv:stmnt
                               {: RESULT = stmnt; :}
                               |
                               USROPER:opr
                               {: RESULT = opr; :}
                               |
                               LPAREN actionStatement:stmt RPAREN
                               {: RESULT = stmt; :}
                               |
                               removefromlist:stmt
                               {: RESULT = stmt; :}
                               |
                               throwRulesException:stmt
                               {: RESULT = stmt; :}
                               ; 					

  conditionStatement      ::=  bexpression:exp
                               {: RESULT = exp; :}
                               |
                               CPOSTFIX:pfx
                               {: RESULT = pfx; :}
                               ;
 
  exitStatement           ::=  EXIT {: RESULT =""; :};
                               

  setStatement            ::=  SET setPhrase:p
                               {: RESULT = p; :}                               
                               ;

  setPhrase               ::= setPhrase2:p
                              {: RESULT = p + " def"; :}
                              |
                              id:i ARROW setPhrase2:p
                              {: RESULT = p + " "+i+" entitypush def entitypop"; :}
                              |
                              id:i1 ARROW id:i2 ARROW setPhrase2:p
                              {: RESULT = p + " "+i1+" entitypush "+i2+" entitypush def entitypop entitypop"; :}
                              |
                              POSSESSION:r setPhrase:p
                              {:   
                                  if(r.equalsIgnoreCase("sponsor")){
                                    RESULT = "{ 'bogus' { pop dup } sponsor if } >> " + p + " entitypop entitypop";
                                  }else{   
                                    RESULT = r + " >> "+ p +" entitypop entitypop ";
                                  }
                              :}
                              |
                              ON POSSESSION:i1 id:i2 setPhrase:p        // Assumes i2 is an entity, and i2+"s" is
                              {:                                        // an array of those entities.
                                RESULT =  "{ "+                         // The old foreach is a for in DTRules
                                             " {" +
                                                 " " + p +  
                                             " } " + i1 + "." + i1 + " " + i1 + " == if" +
                                         " } "+ i2 +"s for ";
                              :} 
                              |
                              setPhrase:setSt COMMA SET setPhrase:p
                              {: RESULT = setSt + " " + p ; :}                            
                              |
                              mid:i EQUALS ACOPYOFALLMEMBERSIN id:list WHERE bexpression:test   
                              {: RESULT = "{ { " + i + " " + checkRList(list).substring(0,list.length()-1) 
                                 + " clone addto } " + test + " if } " + list + " for " ; 
                              :}
                              ;

  setPhrase2              ::=  mid:i EQUALS expr:e
                               {: RESULT = "/" + i + " " + e ; :}
                               |
                               mid:i EQUALS bexpression:b 
                               {:                                    
                                   RESULT = "/" + checkReadOnly(i) + " " + b ; 
                               :}                               
                               ;

  ifStatement             ::=  IF bexpression:test THEN actionStatement:stmt
                               {: RESULT = "{ "+stmt+" } "+test+" if"; :}
                               ;

  performStatement	      ::=  TABLENAME:t 
                               {: RESULT = t ; :}
                               ; 

//   sort ascending EDG_individuals by EDG_Individual.TotChildSupIncAmt
//     edg_individuals /edg_individual.totchildsupincamt { &gt; } sort  ;; 

  sortStatement           ::= SORT ASCENDING id:rlist BY id:attribute
                              {: RESULT = rlist +" /"+attribute+" true sortentities "; :}
                              |
                              SORT DESCENDING id:rlist BY id:attribute
                              {: RESULT = rlist +" /"+attribute+" false sortentities "; :}
                              ;
  
  orSubstring            ::=  orSubstring:s OR expr:e
                              {: RESULT = s + " over "+e+" indexof 0 >= ||"; :}
                              |
                              orSubstring:s COMMA expr:e
                              {: RESULT = s + " over "+e+" indexof 0 >= ||"; :}
                              |
                              orSubstring:s COMMA OR expr:e
                              {: RESULT = s + " over "+e+" indexof 0 >= ||"; :}
                              |
                              expr:e
                              {: RESULT = " over "+e+" indexof 0 >= ||"; :}
                              ;     
                            
  isSubstring            ::=  IS orSubstring:s SUBSTRINGOF expr:e2
                              {: RESULT = e2 + " false " + s + " swap pop"; :}
                              ;
  
  isthereStatement        ::=  ISTHERE id:entity IN id:group 
                               {:  RESULT = "false { true  || } " + group + "." +entity +"s"+ " for"  ; :}
                               |                               
                               ISTHERE ELEMENT IN id:list 
                               {:  RESULT = "false { true  || } " + checkRList(list) + " for"  ; :}
                               |                               
                               ISTHERE id:entity IN id:group WHERE bexpression:test
                               {: RESULT = "false { "+test+" || } "+ checkRList(group +"."+entity+"s") + " for"; :}
                               |
                               ISTHERE ELEMENT IN id:list WHERE bexpression:test
                               {: RESULT = "false { "+test+" || } "+ checkRList(list) + " for"; :}
                               |
                               ISTHERE id:entity AND id:entity2 IN id:group WHERE bexpression:test
   					 {: RESULT = "false { "+entity2+" entitypush "+test+" || entitypop } "+
   						                checkRList(group+"."+entity+"s") + " for"; :}
   					 ;
    	 
  thereisnoStatement      ::=  THEREISNO id:entity WITHIN id:group WHERE bexpression:test
                               {: RESULT = "false { "+test+" || } "+ checkRList(group+"."+entity+"s") + " for !"; :}
                               |
                               THEREISNO id:entity IN id:group WHERE bexpression:test
                               {: RESULT = "false { "+test+" || } "+ checkRList(group+"."+entity+"s") + " for !"; :}
                               |
                               THEREISNO ELEMENT IN id:list WHERE bexpression:test
                               {: RESULT = "false { "+test+" || } "+ checkRList(list) + " for !"; :}
                               |
                               THEREISNO ELEMENT IN id:list 
                               {: RESULT = "false { true || } "+ checkRList(list) + " for !"; :}
                               ; 
                                	 
    	 
  findStatement           ::=  FINDAPERSON WHERE bexpression:b ANDSET setPhrase:phrase 
                               {: RESULT = " true { individual entitypush inverserelationship entitypush " +
                                             "{ { pop false "+ phrase + " } "+b+" if } over if "+
                                             "entitypop entitypop "+
                                           "} individual.relationships for pop" ;
                               :} 
			             |
                               FINDINDIVIDUAL IN  id:group ANDSET setPhrase:phrase
                               {: RESULT = "individual " + group + " entitypush { " +
                                             "individual over == "+
                                             "{ individual entitypush " +
                                                phrase +
                                                " entitypop "+
                                             "} swap if "+
                                           "} edg_individuals for " +
                                           "pop entitypop";
                               :} 
                               |
                               FINDAENTITY:entity WHERE bexpression:b ANDSET setPhrase:phrase
                               {: RESULT = "true { "                  +
                                               "{ "                   +
                                                   "{ pop false "     +
                                                        phrase        +
                                                   "} " + b + " if " +
                                                "} over if "         +
                                           "} "+entity+"s for pop";
                       
                               :}  
                               | 
                               FINDAENTITY:entity IN id:group  WHERE bexpression:b ANDSET setPhrase:phrase
                               {: RESULT = "true { "                  +
                                               "{ "                   +
                                                   "{ pop false "     +
                                                        phrase        +
                                                   " } " + b + " if " +
                                                " } over if "         +
                                           " } " + group + "." +entity+"s for pop";
                       
                               :}         
                               |
                               FINDAELEMENT IN id:list WHERE bexpression:b ANDSET setPhrase:phrase 
                               {: RESULT = "true { "                  +
                                               "{ "                   +
                                                   "{ pop false "     +
                                                        phrase        +
                                                   " } " + b + " if " +
                                                " } over if "         +
                                           " } " + checkRList(list) + " for pop";                       
                               :}                                                     
                               |
                               FINDALLPERSONS WHERE bexpression:b ANDFINDINDIVIDUAL IN  
                               id:group ANDSET setPhrase:phrase
                               {: RESULT = "{ individual entitypush inverserelationship entitypush "+
                                              "{ " +
                                                  group +" entitypush "+
                                                  "individual { "+
                                                     "{ "+phrase+" } over individual == if "+
                                                  "} edg_individuals for "+
                                                  "pop entitypop "+
                                              "} "+b+" if entitypop entitypop " +
                                           "} relationships for "; 
                               :}                                                        
                               |
                               FINDALLPERSONS WHERE bexpression:b ANDFINDREFERNCEDINDIVIDUAL IN  
                               id:group ANDSET setPhrase:phrase
                               {: RESULT = "{ individual entitypush inverserelationship entitypush "+
                                              "{ " +
                                                  group +" entitypush "+
                                                  "inverserelationship entitypush individual { "+
                                                     "{ "+phrase+" } over individual == if "+
                                                  "} edg_individuals for entitypop "+
                                                  "pop entitypop "+
                                              "} "+b+" if entitypop entitypop " +
                                           "} relationships for "; 
                               :}                                                        
                               |
                               FINDALLEDGINDIVIDUAL WITHIN id:group ANDSET setPhrase:phrase
                               {: RESULT = "{ "+ phrase + " } edg_group.edg_individuals for pop";
                               :}              
                               ;
  
  addtocontextStatement   ::=  ADD id:i TOTHECONTEXT 
                               {: RESULT = i + " entitypush"; :}
                               |
                               FINDTHEFIRST id:i IN id:list WHERE bexpression:test ANDADDIT TOTHECONTEXT
                               {: RESULT = "true "+
                                              "{  { pop "+i+" false } over "+test+" and if " +
                                              "} "+list+" for " +
                                           "pop entitypush";
                               :}
                               ;


  wherehasStatement       ::=  actionStatement:stmt WHERE id:i HAS bexpression:test 
                               {: RESULT = "true { { {pop false "+stmt+"  } "+test+" if } over if } " + i + "s for pop";
                               :}
                               ;

  copyStatement           ::=  COPY id:i TO id:i2
                               {: RESULT = "/"+ i2 + " " + i + " clone def"; :}                                
					 ;

  edgindivStatement       ::=  EDGINDIVHAS bexpression:test
                               {: RESULT = "false individual.individual { "+
                                               "{ swap "+test+" || swap } over individual == if "+
                                           "} edg_group.edg_individuals for pop";
                               :}
                               ; 
 
  formGroupStatement      ::=  FORMAGROUP id:id CALLED id:variable
                               {: RESULT = "/"+variable+" '"+id+"' createentity def"; :}  
                               |
                               ADD ENTITY:i TO ENTITY:i1
                               {: RESULT =  checkRList(i1 + "s")+ " " + i + " addto" ; :}
                               |
                               ADD ENTITY:i TO RLIST:i1
                               {: RESULT =  i1+ " " + i + " addto" ; :}
                               |
                               ADD ID:i TO RLIST:i1
                               {: RESULT =  i1+ " " + i + " addto" ; :}                              
                               |
                               ADDALL:rlist id:toGroup
                               {: RESULT = toGroup +" entitypush { 'edg_individual' createentity entitypush "+
                                  "/individual individual.individual def "+
                                  "edg_individuals edg_individual addto entitypop "+
                                  "} individuals for entitypop "+ 
                                  " edg_groups "+toGroup +" addto";
                               :}
                               |
                               ADDALL:rlist id:toGroup ANDFOREACH actionStatement:stmt
                               {: RESULT = toGroup +" entitypush { "+
                               "'edg_individual' createentity entitypush "+
                               "/individual individual.individual def "+
                               "edg_individuals edg_individual addto entitypop } "+
                               "individuals for "+
                               "{ individual entitypush "+stmt+" entitypop } edg_individuals for "+
                               "entitypop edg_groups "+toGroup +" addto";
                               :}
                               ;
 
  removefromlist          ::=  REMOVE EACH id:i FROM id:list WHERE bexpression:test
                               {:
                                  RESULT = "{ { " + list + " " + i + " remove } " 
                                            + test + " if} " + list + " forr" ;
                               :}
                               |
                               REMOVE EACH id:i FROM id:list 
                               {:
                                  RESULT = "list clear " ;
                               :} 
                               |
                               REMOVE id:i FROM id:list WHERE bexpression:test
                               {:
                                  RESULT = "{ " + list + " " + i + " remove } " + test + " if ";
                               :} 
                               |
                               REMOVE id:i FROM id:list
                               {:
                                  RESULT = list + " " + i + " remove ";
                               :} 
                               ;

  forAllEdgIndv		  ::=      ADDALL_EDG_INDV ENTITY:id
                               {: RESULT = "{ " + id + " entitypush edg_individuals edg_individual clone addto entitypop " +
                                            "} edg_individuals for";
                               :}
                               |
                               ADDALL_EDG_INDV ENTITY:id ANDFOREACH actionStatement:as
                               {: RESULT = "{ " + id + " entitypush edg_individuals edg_individual clone addto entitypop " +
                                            "} edg_individuals for " +
                                            id + " entitypush { " + as + " } edg_individuals for entitypop";
                               :}                                                            
                               ;
  
  forallStatement	  ::=      actionStatement:stmt FORALL id:id ANDTHEIR id:group2
                               {: RESULT = "{ { " + stmt + " } "+ checkRList(group2) + " for } "+ checkRList(id) + " for"; :}
                               |   
                               actionStatement:stmt FORALL id:id AND id:id2 IN id:group1 ANDTHEIR id:group2
                               {: RESULT = "{ "+id2+" entitypush { " + stmt + " } "+ group2+" for entitypop } "+ checkRList(group1 + "." + id) + " for"; :}
                               |   
                               actionStatement:stmt FORALL id:id IN id:group WHERE bexpression:test   
                               {: RESULT = "{ { "+stmt+" } "+test+" if  } "+ checkRList(group+"."+id) +" for"; :}
                               |
                               actionStatement:stmt FORALL id:id1 AND id:id2 IN id:group WHERE bexpression:test                        
                               {: RESULT = "{ "+id2+" entitypush { "+stmt+" } "+test+" if entitypop } "+ checkRList(group+"."+id1) +" for"; :}
                               |
                               actionStatement:stmt FORALL id:id1 AND id:id2 IN id:group                        
                               {: RESULT = "{ "+id2+" entitypush "+stmt+" entitypop } "+ checkRList(group+"."+id1) +" for"; :}
                               |
                               actionStatement:stmt FORALL id:id1 IN id:id2
                               {: RESULT = "{ "+stmt+" } "+ checkRList(id2+"."+id1) +" for"; :}
                               |
                               actionStatement:stmt FORALL id:id                              
                               {: RESULT = "{ "+stmt+" } "+id+" for"; :}
                               |
                               actionStatement:stmt FORALL id:list WHERE bexpression:test   
                               {: RESULT = "{ { "+stmt+" } "+test+" if  } "+ checkRList(list) +" for"; :}
                               |
                               actionStatement:stmt FOREACH id:id AND id:id2 IN id:group1 ANDTHEIR id:group2
                               {: RESULT = "{ "+id2+" entitypush { " + stmt + " } "+ group2+" for entitypop } "+ checkRList(group1 + "." + id + "s") + " for"; :}
                               |   
                               actionStatement:stmt FOREACH id:id IN id:group WHERE bexpression:test   
                               {: RESULT = "{ { "+stmt+" } "+test+" if  } "+ checkRList(group+"."+id+"s")+ " for"; :}
                               |
                               actionStatement:stmt FOREACH id:id1 AND id:id2 IN id:group WHERE bexpression:test                        
                               {: RESULT = "{ "+id2+" entitypush { "+stmt+" } "+test+" if entitypop } "+ checkRList(group+"."+id1+"s") + " for"; :}
                               |
                               actionStatement:stmt FOREACH id:id1 AND id:id2 IN id:group                        
                               {: RESULT = "{ "+id2+" entitypush "+stmt+" entitypop } "+ checkRList(group+"."+id1+"s") + " for"; :}
                               |
                               actionStatement:stmt FOREACH id:id1 IN id:id2
                               {: RESULT = "{ "+stmt+" } "+ checkRList(id2+"."+id1+"s") + " for"; :}
                               |
                               actionStatement:stmt FOREACH id:id                              
                               {: RESULT = "{ "+stmt+" } "+id+"s for"; :}
                             ;                               

  isaStatement            ::=  ISA id:relationship
                               {: RESULT = "false { relationshipcd "+relationship+" == || "+
                                           "} individual.relationships for ";
                               :}
                               |
                               ISA id:relationship TOAPERSON WHERE bexpression:test
                               {: RESULT = "false { "+
                                             "individual entitypush "+
                                             "{ "+test+" || } relationshipcd " + relationship + " == if "+
                                             "entitypop "+
                                           "} relationships for";
							   :}
							   ;
							   
  hasaStatement           ::=  HASA id:relationship                                         
                               {: RESULT = "false { individual entitypush inverserelationship entitypush "+
                                           "relationshipcd "+relationship+" == || entitypop entitypop " +
                                           "} individual.relationships for";
                               :}
                               |
                               HASA id:relationship WHERE bexpression:test 
                               {: RESULT = "false { individual entitypush inverserelationship entitypush "+
                                           "{ "+test+" || } relationshipcd " + relationship +" == if entitypop entitypop "+
                                           "} individual.relationships for ";
                               :}
                               |
                               HASA id:relationship whohasaStatement:test 
                               {: RESULT = "false { individual entitypush inverserelationship entitypush "+
                                           "{ "+test+" } relationshipcd " + relationship +" == if entitypop entitypop "+
                                           "} individual.relationships for ";
                               :}
                               ;
  
  hasapersonStatement      ::= HASAPERSON WHERE bexpression:test
                               {: RESULT = "false { "+
                                              "individual entitypush inverserelationship entitypush "+
                                              test + " ||  entitypop entitypop "+
                                           "} individual.relationships for";
                               :}
                               |
                               HASAPERSON whohasaStatement:test 
                               {: RESULT = "false { "+
                                              "individual entitypush inverserelationship entitypush "+
                                              test + " entitypop entitypop "+
                                           "} individual.relationships for";
                               :}
                               ;            

  whohasaTest              ::= whohasaStatement:stmt
                               {: RESULT = " false " + stmt; :}
                               ;

  whohasaStatement         ::= WHOHASA id:relationship
                               {: RESULT = "{ individual entitypush inverserelationship entitypush " +
                                                "relationshipcd " + relationship +" == || "+
                                                "entitypop entitypop "+
                                           "} individual.relationships for ";
                               :}
                               |
                               WHOHASA id:relationship WHERE bexpression:test
                               {: RESULT = "{ individual entitypush inverserelationship entitypush " +
                                                "{ "+test+" || } relationshipcd " + relationship +" == if "+
                                                "entitypop entitypop " +
                                           "} individual.relationships for ";
                               :}
                               |
                               WHOHASA id:relationship whohasaStatement:test
                               {: RESULT = "{ individual entitypush inverserelationship entitypush " +
                                                "{ "+test+" } relationshipcd " + relationship +" == if "+
                                                "entitypop entitypop " +
                                           "} individual.relationships for ";
                               :}
                              ;	
                              
//Does every child of the Individual have a parent whose eligibleStudent = true 
//OldPostFix : true { individual entitypush inverserelationship entitypush { false { individual entitypush inverserelationship entitypush { eligiblestudent true == || } relationshipcd parent == if entitypop entitypop } relationships for &amp;&amp; } relationshipcd child == if entitypop entitypop } relationships for

  doesStatement           ::= DOES EVERY id:r1 OFINDIVIDUALHAVE id:r2 WHERE bexpression:b
                               {: RESULT = " true { individual entitypush inverserelationship entitypush "+
                                              "{ false "+
                                                 "{ individual entitypush inverserelationship entitypush "+
                                                   "{ eligiblestudent true == || } relationshipcd "+r2+" == if "+
                                                   "entitypop entitypop "+
                                                 "} relationships for && "+
                                              "} relationshipcd "+r1+" == if "+
                                           "entitypop entitypop } relationships for ";
                               :}
                               ;

// Is test1 for every entity in list WHERE test2
  isforeverytest ::= IS bexpression:b1 FOREVERY id:i IN id:i2 WHERE bexpression:b2
                       {:  RESULT = " true { { "+b1+" && } "+ b2 +" if } "+ i2 +" for";  :}
                     ;

// || is false (any) and && is true (all)

foranyalloftheStmnt   ::=     boolexpr:e1 FORANYOFTHE id:rlist               
                               {: RESULT = " false { " + e1 + " || } " +  rlist + " for " ; :}
                               |
                               boolexpr:e1 FORALLOFTHE id:rlist               
                               {: RESULT = " true  { " + e1 + " && } " +  rlist + " for " ; :}
                               |
                               boolexpr:e1 FORANYOFTHE:opr id:rlist IN id:group              
                               {: RESULT = " false { " + e1 + " || } " +  group + "." + rlist + " for " ; :}                               
                               |                               
                               boolexpr:e1 FORALLOFTHE:opr id:rlist IN id:group              
                               {: RESULT = " true  { " + e1 + " && } " +  group + "." + rlist + " for " ;  :}                               
                               |                               
                               foranyalloftheStmnt:e1 FORANYOFTHE:opr id:rlist              
                               {: RESULT = "false { " + e1 + " || } " + rlist + "  for";  :}                              
                               |                               
                               foranyalloftheStmnt:e1 FORALLOFTHE:opr id:rlist              
                               {: RESULT = "true  { " + e1 + " && } " + rlist + "  for";  :}                              
                               |
                               foranyalloftheStmnt:e1 FORANYOFTHE:opr id:rlist IN id:group               
                               {: RESULT = "false { " + e1 + " || } " + group + "." + rlist + "  for"; :} 
                               |
                               foranyalloftheStmnt:e1 FORALLOFTHE:opr id:rlist IN id:group               
                               {: RESULT = "true { " + e1 + " && } " + group + "." + rlist + "  for"; :} 
                               ;
                                                                           
 foranyallwhereStmnt  ::=      boolexpr:e1 FORANYOFTHE:opr id:rlist WHERE boolexpr:test              
                               {: RESULT = "false { { " + e1 + " || } " + test + " if " + " } " + rlist + " for " ; :}
                               |
                               boolexpr:e1 FORALLOFTHE:opr id:rlist WHERE boolexpr:test              
                               {: RESULT = "true  { { " + e1 + " && } " + test + " if " + " } " + rlist + " for " ; :}
                               |
                               boolexpr:e1 FORANYOFTHE:opr id:rlist IN id:group WHERE boolexpr:test             
                               {: RESULT = "false { { "+e1+" || } "+test+" if "+" } "+group+"."+rlist+" for "; :}                               
                               |
                               boolexpr:e1 FORALLOFTHE:opr id:rlist IN id:group WHERE boolexpr:test             
                               {: RESULT = "true  { { "+e1+" && } "+test+" if "+" } "+group+"."+rlist+" for "; :}                               
                               ;

 throwRulesException ::=  THROWRULESEXCEPTION STR:str
                          {: RESULT = str + " throwexception" ; :}
                          |
                          THROWRULESEXCEPTION ID:id
                          {: RESULT = id + " throwexception" ; :}
                          ;

 deepcopyLists      ::=  ACOPYOFALLMEMBERSIN id:i            
                         {:  RESULT = i +" deepcopy"; :}                                                          
                         ;

 lookupExpression ::=  LOOKUP expr:e1 USINGCOLUMN expr:e2 FROMTABLE expr:e3 FORDATE expr:e4 
                       {: RESULT = e1+" "+e2+" "+e3+" "+e4+" tabledatelookup"; :}
                       |
                       LOOKUP expr:e1 USINGCOLUMN expr:e2 FROMTABLE expr:e3  
                       {: RESULT = e1+" "+e2+" "+e3+" tablelookup"; :}
                       |
                       LOOKUP CODE expr:e1 USINGCOLUMN expr:e2 FROMTABLE expr:e3 FORDATE expr:e4 
                       {: RESULT = e1+" "+e2+" "+e3+" "+e4+" tabledatelookupforcode"; :}
                       |
                       LOOKUP CODE expr:e1 USINGCOLUMN expr:e2 FROMTABLE expr:e3  
                       {: RESULT = e1+" "+e2+" "+e3+" tablelookupforcode"; :}
                       |
                       LOOKUP expr:e1 USINGCOLUMN expr:i1 AND expr:i2 FROMTABLE expr:e3 FORDATE expr:e4 RETURNING expr:e5
                       {: RESULT = e1+" "+i1+" "+i2+" "+e3+" "+e4+" " +e5+" lookupMultipleParmTable"; :}
                       ;
                                                 
  bexpression  ::=  boolexpr:exp 
                    {: RESULT = exp; :}
                    ;
  
  expr   ::= term:t
             {: RESULT = t; :}
             |
             LPAREN expr:e RPAREN
             {: RESULT = e; :}
             |                 
             LESSEROF expr:e1 OR expr:e2
             {: RESULT =  e1 + " " + e2 + " min"; :}
             |                          
             GREATEROF expr:e1 OR expr:e2
             {: RESULT =  e1 + " " + e2 + " max"; :}
             |
             expr:e1 ROUNDED expr:e2 ORMORE
             {: RESULT = e1 +" "+e2+" round"; :}
             |
             expr:e1 SCALED INTEGER:n DECPLACES
             {: 
                String zeros  = "0000000000000000000000000000000000000000";
                String sConst = "1" + zeros.substring(0,Integer.parseInt(n));
                RESULT = e1 + " " + sConst + " * 1 round " + sConst +" div"; 
             :}
             |
             expr:e1 SCALED INTEGER:n DECPLACES ROUNDED expr:e2 ORMORE
             {: 
                String zeros = "0000000000000000000000000000000000000000";
                String sConst = "1"+zeros.substring(0,Integer.parseInt(n));
                RESULT = e1 + " " + sConst + " * "+e2+" round " + sConst +" div"; 
             :}
             |
             expr:e1 TIMES:op expr:e2
             {: RESULT = e1+" "+e2+" "+op; :} 
             | 
             expr:e1 DIVIDE:op expr:e2
             {: RESULT = e1+" "+e2+" "+op; :} 
             | 
             expr:e1 PLUS:op expr:e2
             {: RESULT = e1+" "+e2+" "+op; :} 
             | 
             expr:e1 PLUSSTR:op expr:e2
             {: RESULT = e1+" "+e2+" "+op; :} 
             |
             expr:e1 MINUS:op expr:e2
             {: RESULT = e1+" "+e2+" "+op; :} 
             | 
             MINUS:op expr:e1 
             {: RESULT = " 0 "+e1+" - "; :}
             %prec UNIMINUS
             |
             USING id:i 
             {: RESULT = i + " entitypush "; :}
                expr:e
             {: RESULT +=  e + " entitypop"; :}
             |
             NUMBEROFTIMEPERIOD:p BETWEEN expr:e1 AND expr:e2 
             {: RESULT = e1 + " " + e2 + " " + p ; :}             
             |
             lookupExpression:e1
             {: RESULT = e1; :}                          
             |             
             expr:e1 END OF TIMEPERIOD:t
             {: 
                if(!t.equals("months")) throw new Error("invalid syntax: "+t);
                RESULT = e1+" endofmonth"; 
             :}
             |
             expr:e1 START OF TIMEPERIOD:t
             {: 
                if(!t.equals("months")) throw new Error("invalid syntax: "+t);
                RESULT = e1+" startofmonth"; 
             :}
             |
             POSSESSION:r id:i
                {:
                    if(r.equalsIgnoreCase("sponsor")){
                       RESULT = "{ 'bogus' { pop dup } sponsor if } >> " + i + " entitypop entitypop";
                    }else{   
                       RESULT = r + " >> "+ i +" entitypop entitypop"; 
                    }
                :}
             
             |
             id:i ARROW expr:e
             {: RESULT = i +" entitypush "+e+" entitypop"; :}             
             |
             SIZEOF id:list 
             {: RESULT = checkRList(list) + " sizeof" ; :} 
             |
             deepcopyLists:id 
             {: RESULT = id ; :}
             ;   
            

  term      ::= id:i
                {: RESULT = i; :}
                | 
                STR:s
                {: RESULT = s; :}
                |
                number:n
                {: RESULT = n; :}
                ;

  id        ::= ID:i
                {: RESULT = i; :}
                |
                ENTITY:e
                {: RESULT = e; :}
                |
                RLIST:rl
                {: RESULT = rl; :}
                |
		        TIMEPERIOD:t OF id:i
		        {: if(t.equals("years"))  t = "year";
                   if(t.equals("months")) t = "month";
                   if(t.equals("day"))    t = "day";
                   RESULT = i + " " + t + "of";
                :}
                |
                id:i TIMEPERIOD:t
                {: RESULT = i + " " + t ; :}
                |
                SUMOFEACH id:i1 FORALL id:i2 WHERE bexpression:test
                {:
                   RESULT = "0 { { "+i1+" + } "+test+" if } "+i2+" for";
                :}
		        |
		        SUMOFEACH id:i1 FORALL id:i2
                {:
                   RESULT = "0 { "+i1+" + } "+i2+" for";
                :}
                ; 

  mid        ::= ID:i
                {: RESULT = checkReadOnly(i); :}
                |
                BOOL_ID:e
                {: RESULT = e; :}
                |
                ENTITY:e
                {: RESULT = e; :}
                |
                RLIST:rl
                {: RESULT = rl; :}
                |
                mid:i TIMEPERIOD:t
                {: RESULT = i + " " + t ; :}                           
                ;    
   
  number     ::= INTEGER:i
                 {: RESULT = i; :}
                 |
                 FLOAT:r 
                 {: RESULT = r; :}
                 |
                 INTEGER:i TIMEPERIOD:t
                 {: RESULT = i + " " + t ; :}
                 |
                 BIGDECIMAL:bg
                 {: RESULT = bg; :}
                 ;                

  commaexpr ::=	expr:e1 COMMA commaexpr:ceq
                {:   RESULT = firstexp +" "+e1+" == || "+ceq; :}
                |
                expr:e1 COMMA OR commaexpr:ceq
                {:   RESULT = firstexp +" "+e1+" == || "+ceq; :}
                |
                expr:e1 OR commaexpr:ceq
                {: RESULT = firstexp +" "+e1+" == || "+ceq; :}
                |
                expr:e1
                {: 	RESULT = firstexp + " "+e1+" == || "; :}                
		        ;

  commaListExpr ::= expr:id COMMA commaListExpr:ceq
                {:     
                    RESULT  = id + " \",\"" + " + " + ceq + " + ";
                :}
                |
                expr:id
                {:   RESULT = id ; :}                
                ;


  commaPhrase ::= expr:e1 EQUALS:op expr:e2 
                {:  
                    firstexp = e1;
                    RESULT = e1 +" "+ e2 +" == "; 
                :}
                COMMA commaexpr:ceq
                {: RESULT += ceq;:}
                |
                LISTEQUALS expr:e1 EQUALS:op expr:e2 
                {:  
                    firstexp = e1;
                    RESULT = e1 +" "+ e2 +" == "; 
                :}
                COMMA commaexpr:ceq
                {: RESULT += ceq; :}
                |
                COMMALIST commaListExpr:ceq              
                {: RESULT = ceq; :}
                ;
              
  boolexpr  ::= TRUEIF boolexpr:b
                {: RESULT = b; :}
		    |
                FALSEIF boolexpr:b
                {: RESULT = b + " !"; :}
                |
                expr:e1 LESSTHAN:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}
                |
                expr:e1 GREATERTHAN:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}                                
                |
                commaPhrase:cp
                {: RESULT = cp;  :}
                |                
                expr:e1 EQUALS:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}
                |
                expr:e1 NOTEQUALS:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}
                |
                expr:e1 GREATERTHANEQUALS:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}
                |
                expr:e1 LESSTHANEQUALS:op expr:e2
                {: RESULT = e1 + " " + e2 + " " + op; :}
                |                
                boolexpr:b1 EQUALS:op boolexpr:b2
                {: RESULT = b1 + " " + b2 + " " + op; :}
                |
                boolexpr:b1 AND:op boolexpr:b2
                {: RESULT = b1 + " " + b2 + " " + op; :}
                |
                boolexpr:b1 OR:op boolexpr:b2
                {: RESULT = b1 + " " + b2 + " " + op; :}
                |
                NOT:op boolexpr:b
                {: RESULT = b + " !"; :}
                |
                whohasaTest:exp 
                {: RESULT = exp; :}
                |
		        isforeverytest:exp
                {: RESULT = exp; :}
                |
		        id:i ISAMEMBEROF id:rlist
                {: RESULT = rlist +" "+ i + " memberof"; :}
                |
                id:list1 INCLUDESMEMBER id:list2
                {: RESULT = list1 + " " + list2 + " intersects"; :}
                |
                hasaStatement:exp 
                {: RESULT = exp; :}
                | 
                hasapersonStatement:exp
                {: RESULT = exp; :}
                | 
                edgindivStatement:exp 
                {: RESULT = exp; :}
                | 
                isthereStatement:exp
                {: RESULT = exp; :}
                | 
                isSubstring:exp
                {: RESULT = exp; :}
                | 
                thereisnoStatement:exp
                {: RESULT = exp; :}
                | 
                doesStatement:exp
                {: RESULT = exp; :}                
                |
                isaStatement:exp
                {: RESULT = exp; :}
                |
                USING ENTITY:id boolexpr:b
                {: RESULT = id + " entitypush " + b + " entitypop"; :}
                |
                LPAREN boolexpr:b RPAREN 
                {: RESULT = b; :}
                |
                DATEMODIFIER:m  boolexpr:e 
                {: RESULT = m + " " + e +" setday "; :} 
                |
                expr:b ABSOLUTETIME:t
                {:                 
                   RESULT = b +" " + t ;
                :}             
                |                
                POSSESSION:r boolexpr:b
                {:
                    if(r.equalsIgnoreCase("sponsor")){
                       RESULT = "{ 'bogus' { pop dup } sponsor if } >> " + b + " entitypop entitypop";
                    }else{   
                       RESULT = r + " >> "+ b +" entitypop entitypop"; 
                    }
                :}
                |
                BOOL:b
                {: RESULT = b; :}
                |
                BOOL_ID:i
                {: RESULT = i; :}
                |
                id:i ARROW boolexpr:e
                {: RESULT = i +" entitypush "+e+" entitypop"; :}
                |                
                foranyalloftheStmnt:b                
                {: RESULT = b; :}                  
                |
                foranyallwhereStmnt:b
                {: RESULT = b; :}    
                ;


 